# 内存管理机制

## 1.内存管理

### 1.1C++内存管理详解

#### 1.1.1内存分配方式

##### 1.1.1.1分配方式简介

在C++中，内存分为五个区：

- **堆：**由new分配的内存块，它们的释放编译器不去管，由我们的应用程序区控制，一般一个new就要对应一

​                 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。



- **栈：**在执行函数时，函数局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储单元自动被释

  ​        放。栈内存分配运算内置于处理器的指令集中，效率很高但是分配的内存容量有限。

  

- **自由存储区：**由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。



- **全局/静态存储区：**全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化

​                                         和未初始化的，在C++里面没有这个区分，它们共同占用一块内存区。



- **常量存储区：**这是一块比较特殊的存储区，它们里面存放的是常量，不允许修改。

##### 1.1.1.2明确区分堆与栈

```c++
void f(){int* p=new int[5];}
短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？它分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，它在VC6下的汇编代码如下：
00401028 push 14h
0040102A call operator new (00401060)
0040102F add esp,4
00401032 mov dword ptr [ebp-8],eax
00401035 mov eax,dword ptr [ebp-8]
00401038 mov dword ptr [ebp-4],eax

这里我们为了简单并没有释放内存，那么该怎么去释放呢？应该用delete[]p，这是为了告诉编辑器：我删除
```

##### 1.1.1.3堆和栈究竟有什么区别？

主要的区别有以下几点：

- **管理方式：**

  栈：编译器自动管理，无需手动控制。

  堆：释放工作由程序员控制，容器产生memory leak。



- **空间大小：**

  堆：在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。

  栈：有一定的空间大小。



- **碎片问题：**

  堆：频繁的new/delete势必会造成内存空间不连续，从而造成大量的碎片，是程序效率降低。

  栈：栈是先进后出的队列，是一一对应的，以至于永远都不可能有一个内存块从栈中间弹出，在它弹出之前，在它上面的后进的栈内容已经被弹出。



- **生长方向：**

  堆：生长方向是向上的，也就是向着地址增加的方向增长

  栈：生长方向是向下的，也就是向着地址减小的方向增长



- **分配方式：**

  堆：动态分配。

  栈：栈有两种分配方式。静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配有allocate函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手动实现。



- **分配效率：**

  堆：堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低很多。

  栈：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执。

虽然栈有如此多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。

无论是堆还是栈，都要防止越界现象发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生意想不到的结果。

#### 1.1.2

##### 1.1.2.1重载全局的new和delete操作符

```c++
可以很容易地重载new和delete操作符
void* operator(size_t size)
{
void*p=malloc(size);
return p;
}
void operator delete(void*p)
{
free(p);
}
```

也可以对单个类的new和delete操作符重载。因此可以灵活地控制对象的内存分配

```c++
class TestClass {

public:

void * operator new(size_t size);

void operator delete(void *p);

// .. other members here ...
};

void *TestClass::operator new(size_t size)
{
void *p = malloc(size); // Replace this with alternative allocator
{
return (p);
}

void TestClass::operator delete(void *p)
{
free(p); // Replace this with alternative de-allocator
}

所有TestClass对象的内存分配都采用这段代码。更进一步，任何从TestClass继承的类也都采用这一方式，除非它自己也重载了new和delete操作符。通过重载new和delete操作符的方式，可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。
```

##### 1.1.2.2为单个的类重载new[]和delete[]

必须小心对象数组的分配。你可能希望调用到被你重载过的new和delete操作符，但并不如此。内存的请求被定向到全局的new[]和delete[]操作符，而这些内存来自于系统堆。

C++将对象数组的内存分配作为一个单独操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载new[]和delete[]操作符

```C++
class TestClass {

public:

void * operator new[ ](size_t size);

void operator delete[ ](void *p);

// .. other members here ..

};

void *TestClass::operator new[ ](size_t size)

{

void *p = malloc(size);

return (p);

}

void TestClass::operator delete[ ](void *p)

{

free(p);

}

int main(void)

{

TestClass *p = new TestClass[10];

// ... etc ...

delete[ ] p;

} 
```

但是注意，对于大多数C++的实现，new[]操作符的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。应该尽量避免分配对象数组，从而使你的内存分配策略简单。

#### 1.1.3常见的内存错误及其对策

- **内存分配未成功，你却使用了它：**

  在使用内存前检查指针是否为NULL，如果指针p是函数的参数，那么在函数的入口处用assert（p！=NULL）进行检查。如果是用malloc或new来申请内存，应该用if（p==NULL）或if（p！=NULL）进行防错处理。

  

- **内存分配虽然成功，但是尚未初始化就引用它：**

  两个原因：一是没有初始化观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略。

  

- **内存分配成功并且已经初始化，但操作越过了内存的边界：**

  例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。



- **忘了释放内存，造成内存泄漏：**

  含有这种错误的函数每被调用一次就丢失一块内存。刚开始系统的内存太足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。

  动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。



- **释放了内存还继续使用：**

  有三种情况：

  
