# 内存管理机制

## 1.内存管理

### 1.1C++内存管理详解

#### 1.1.1内存分配方式

##### 1.1.1.1分配方式简介

在C++中，内存分为五个区：

- **堆：**由new分配的内存块，它们的释放编译器不去管，由我们的应用程序区控制，一般一个new就要对应一

​                 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。



- **栈：**在执行函数时，函数局部变量的存储单元都可以在栈上创建，函数执行结束时，这些存储单元自动被释

  ​        放。栈内存分配运算内置于处理器的指令集中，效率很高但是分配的内存容量有限。

  

- **自由存储区：**由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。



- **全局/静态存储区：**全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化

​                                         和未初始化的，在C++里面没有这个区分，它们共同占用一块内存区。



- **常量存储区：**这是一块比较特殊的存储区，它们里面存放的是常量，不允许修改。

##### 1.1.1.2明确区分堆与栈

```c++
void f(){int* p=new int[5];}
短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？它分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，它在VC6下的汇编代码如下：
00401028 push 14h
0040102A call operator new (00401060)
0040102F add esp,4
00401032 mov dword ptr [ebp-8],eax
00401035 mov eax,dword ptr [ebp-8]
00401038 mov dword ptr [ebp-4],eax

这里我们为了简单并没有释放内存，那么该怎么去释放呢？应该用delete[]p，这是为了告诉编辑器：我删除
```

##### 1.1.1.3堆和栈究竟有什么区别？

主要的区别有以下几点：

- **管理方式：**

  栈：编译器自动管理，无需手动控制。

  堆：释放工作由程序员控制，容器产生memory leak。



- **空间大小：**

  堆：在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。

  栈：有一定的空间大小。



- **碎片问题：**



- **生长方式：**



- **分配方式：**



- **分配效率：**



